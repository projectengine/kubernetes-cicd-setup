{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Anasayfa","text":"<p>Kubernetes CI/CD Kurulumu ve \u00c7e\u015fitli \u00d6rnekler</p>"},{"location":"#kurulum","title":"Kurulum","text":"<ol> <li>kind</li> <li>gitlab (gitea ya da daha basit bi\u015fey olabilir)</li> <li>argocd</li> <li>external-secrets (secret'lar i\u00e7in)</li> </ol>"},{"location":"#dersler","title":"Dersler","text":"<ol> <li>docker</li> <li>docker run</li> <li>docker ps</li> <li>docker exec</li> <li>docker run -v</li> <li>stop, start, rm</li> <li>kubernetes</li> <li>kubectl run</li> <li>kubectl exec</li> <li>apply -f</li> <li>delete -f</li> <li>namespace</li> <li>proxy</li> <li>ingress</li> <li>volume</li> <li>config ve secret</li> <li>ci/cd</li> <li>gitlab ci</li> <li>deploy projesi</li> <li>argocd</li> <li>commit, merge, pipeline</li> </ol>"},{"location":"cicd/","title":"CI/CD","text":""},{"location":"docker/1-kurulum/","title":"Kurulum","text":"<p>A\u015fa\u011f\u0131daki linklerden faydalanarak docker kurulumunu yapabilirsiniz.</p> <ul> <li>Docker Desktop</li> <li>Docker Linux</li> </ul>"},{"location":"docker/2-helloworld/","title":"Hello World","text":"<p><code>docker run hello-world</code> komutu ile basit bir imaj\u0131 bilgisayar\u0131n\u0131za \u00e7ekip \u00e7al\u0131\u015ft\u0131rabilirsiniz. Container \u00e7al\u0131\u015ft\u0131\u011f\u0131 zaman a\u015fa\u011f\u0131daki \u00e7\u0131kt\u0131y\u0131 \u00fcretir:</p> <pre><code>Hello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre>"},{"location":"docker/3-port/","title":"Portlar","text":"<p><code>docker run -p 8000:8000 jwilder/whoami</code> komutu ile ekrana hostname'ini yazan bir web uygulamas\u0131 \u00e7al\u0131\u015ft\u0131ral\u0131m. Uygulama 8000 portundan yay\u0131n yap\u0131yor.</p> <p>Taray\u0131c\u0131mz\u0131dan http://localhost:8000 sayfas\u0131n\u0131 a\u00e7t\u0131\u011f\u0131m\u0131zda <code>I'm 7b5c6dc7a66b</code> gibi bir metin g\u00f6rmekteyiz.</p> <p>Bu \u015fekilde <code>run</code> komutuna verdi\u011fimiz <code>-p host-port:container-port</code> arg\u00fcman\u0131 ile container i\u00e7inde \u00e7al\u0131\u015fan uygulamaya container'\u0131n d\u0131\u015f\u0131ndan eri\u015febilmekteyiz.</p> <p>Not</p> <p><code>docker run</code> komutunda genelde ba\u011flant\u0131lar <code>host:container</code> \u015feklinde verilir (\u00f6r. portlar, volume'ler)</p>"},{"location":"docker/4-volume/","title":"Volume","text":"<p>Volume'ler, container'lar\u0131n host makinedeki dosya ve dizinleri kullanabilmesi ya da container i\u00e7inde de\u011fi\u015fiklik yap\u0131lan dosya ve dizinlerin korunmas\u0131 i\u00e7in kullan\u0131l\u0131r.</p>"},{"location":"docker/4-volume/#host-makinedeki-dizini-kullanma","title":"Host makinedeki dizini kullanma","text":"<p>\u00d6nce i\u00e7inde 'Hello Docker' yaz\u0131l\u0131 <code>hello.txt</code> dosyas\u0131n\u0131 olu\u015ftural\u0131m. Ard\u0131ndan a\u015fa\u011f\u0131daki komutla container'\u0131m\u0131z\u0131 \u00e7al\u0131\u015ft\u0131r\u0131p dosyay\u0131 da i\u00e7indeki bir dizine almas\u0131n\u0131 s\u00f6yleyelim:</p> <p><code>docker run -v $(pwd)/hello.txt:/tmp/hello.txt busybox cat /tmp/hello.txt</code></p> <p>Bu komut \u00e7al\u0131\u015ft\u0131\u011f\u0131nda container ekrana 'Hello Docker' yaz\u0131p kapanacak. Container bu metni, olu\u015fturdu\u011fumuz dosyadan okuyor ve dosyay\u0131 da volume ile kendi sistemine al\u0131yor.</p> <p>Bu tip volume'lerin kullan\u0131m alan\u0131 genelde config dosyalar\u0131n\u0131 container'a d\u0131\u015far\u0131dan vermektir. Bu tarz bir kullan\u0131m \u00f6rne\u011fini Dockerfile yazmaya ba\u015flad\u0131\u011f\u0131m\u0131zda g\u00f6rece\u011fiz.</p>"},{"location":"docker/4-volume/#container-icindeki-degisiklikleri-koruma","title":"Container i\u00e7indeki de\u011fi\u015fiklikleri koruma","text":"<p>Bu kullan\u0131m \u015fekli i\u00e7in bir veritaban\u0131 container'\u0131 aya\u011fa kald\u0131ral\u0131m.</p> <p><code>docker run -d --name postgres -e POSTGRES_PASSWORD=123456 postgres:15-alpine</code></p> <p>Veritaban\u0131n\u0131n loglar\u0131n\u0131 <code>docker logs -f postgres</code> komutu ile g\u00f6rebiliriz. \u00d6nceki komuttaki <code>-d</code> arg\u00fcman\u0131 container'\u0131n arkaplanda \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011fl\u0131yor. B\u00f6ylece <code>ctrl + c</code> yapt\u0131\u011f\u0131m\u0131zda container kapanm\u0131yor. <code>-e</code> ile de container'a ortam de\u011fi\u015fkeni verebiliyoruz. Bunu da genelde container'\u0131n ayarlar\u0131n\u0131 de\u011fi\u015ftirmek i\u00e7in kullan\u0131yoruz.</p> <p>Veritaban\u0131m\u0131z aya\u011fa kalk\u0131nca <code>docker exec -it postgres sh</code> komutu ile container'\u0131n terminaline girebiliriz. <code>exec</code> aslen container i\u00e7inde bir komut \u00e7al\u0131\u015ft\u0131rmaya yar\u0131yor. Biz komut olarak <code>sh</code> yani terminal komutu kullan\u0131yoruz ve <code>-it</code> ile interaktif yani sadece sonucunu basmak yerine yaz\u0131labilir olmas\u0131n\u0131 s\u00f6yl\u00fcyoruz.</p> <p>Container'n\u0131 terminali a\u00e7\u0131l\u0131nca a\u015fa\u011f\u0131daki komutlarla veritaban\u0131na ba\u011flan\u0131p birka\u00e7 de\u011fi\u015fiklik yapal\u0131m.</p> <pre><code>psql -U postgres # Veritaban\u0131na ba\u011flan\n\\dt # Did not find any relations.\ncreate table yeni (id serial, name text); # tablo yarat\n\\dt\n#         List of relations\n# Schema | Name | Type  |  Owner   \n#--------+------+-------+----------\n# public | yeni | table | postgres\n#(1 row)\nexit\n</code></pre> <p>\u015eimdi <code>exit</code> yazarak terminalden de \u00e7\u0131kal\u0131m ve <code>docker rm -f postgres</code> ile container'\u0131 silelim. Yapt\u0131\u011f\u0131m\u0131z de\u011fi\u015fiklikler art\u0131k yok.</p> <p>Bu de\u011fi\u015fikliklerin kal\u0131c\u0131 olmas\u0131n\u0131 istiyorsak (\u00f6rne\u011fin container imaj\u0131n\u0131 g\u00fcncellerken, veriyi farkl\u0131 bir container i\u00e7in kullan\u0131rken vs.) volume \u00f6zelli\u011fini kullanabilriiz. Bunun i\u00e7in \u00f6nce bir volume olu\u015fturup sonra ilk komutumuza bir arg\u00fcman daha ekliyoruz.</p> <ol> <li><code>docker volume create db</code></li> <li><code>docker run -d --name postgres -e POSTGRES_PASSWORD=123456 -v db:/var/lib/postgresql/data postgres:15-alpine</code></li> </ol> <p>Yukar\u0131daki i\u015flemleri bu container i\u00e7in de uygulayal\u0131m (psql ile ba\u011flan, tablo yarat, tablolar\u0131 listele, \u00e7\u0131k\u0131\u015f yap). Sonra container'\u0131 silelim ve 2 nolu komutu kullanalarak yeniden olu\u015ftural\u0131m. Bu kez veritaban\u0131na ba\u011flan\u0131p <code>\\dt</code> ile listeledi\u011fimizde yeni tablosunun oldu\u011funu g\u00f6rebiliriz.</p>"},{"location":"docker/5-bash/","title":"Bash","text":"<p>Bu ba\u015fl\u0131kta docker'\u0131n en yayg\u0131n kullan\u0131m alanlar\u0131ndan biri olan ge\u00e7ici \u00e7al\u0131\u015fma ortamlar\u0131n\u0131 inceleyece\u011fiz.</p> <p>Bir container'\u0131n terminaline girmek i\u00e7in iki yol vard\u0131r. E\u011fer container \u00e7al\u0131\u015f\u0131yorsa <code>docker exec</code> komutu kullan\u0131l\u0131r.</p> <p>A\u015fa\u011f\u0131da buna \u00f6rnek olarak bir <code>busybox</code> container'\u0131 \u00e7al\u0131\u015ft\u0131r\u0131p <code>exec</code> ile terminaline giriyoruz:</p> <pre><code># busybox imaj\u0131 ile bir container ba\u015flat.\n# sleep komutu container'\u0131n bir s\u00fcre a\u00e7\u0131k kalmas\u0131n\u0131 sa\u011flar.\n# --rm ile i\u015fimiz bitince container'\u0131n silinmesini sa\u011fl\u0131yoruz\n# --name ile kolay eri\u015fim i\u00e7in bir isim veriyoruz.\n# -d ile container'\u0131n arka planda a\u00e7\u0131lmas\u0131n\u0131 sa\u011fl\u0131yoruz. B\u00f6ylece arkas\u0131ndan ba\u015fka bir komut yazabiliriz.\ndocker run --rm -d --name debug busybox sleep 60000\n\n# exec ile container'\u0131n terminaline gir.\ndocker exec -it debug sh\n\n/ # cat /etc/hostname\n9c47c8133eed\n</code></pre> <p>Bu y\u00f6ntem ile \u00e7al\u0131\u015fmakta olan container'lar\u0131n terminaline giri\u015f yap\u0131p sorunlar\u0131n\u0131 \u00e7\u00f6zebilir, i\u00e7inde de\u011fi\u015fiklik yapabilir ya da dosyalar\u0131na bakabiliriz. Container'lar\u0131 debug etmek i\u00e7in genelde bu y\u00f6ntem kullan\u0131l\u0131r</p> <p>\u0130kinci y\u00f6ntem ise container'\u0131 a\u00e7arken terminal ba\u015flatmakt\u0131r. Bu \u015fekilde genelde yukar\u0131da bahsetti\u011fim \u00e7al\u0131\u015fma ortamlar\u0131n\u0131 kullanabiliriz. \u00d6rnek olarak yine ayn\u0131 imaj\u0131 kullanal\u0131m:</p> <pre><code># -it arg\u00fcmanlar\u0131 terminal komutu (sh) ile birlikte kullan\u0131l\u0131r.\n# Bunlar olmazsa docker bir\u015feyler yazmam\u0131za m\u00fcsade etmeden container'\u0131 kapat\u0131r.\n\u276f docker run -it --rm busybox sh\n/ # cat /etc/hostname \nf8798ad38f50\n</code></pre> <p>Daha ger\u00e7ek\u00e7i bir \u00f6rnek ele alal\u0131m. Bilgisayar\u0131m\u0131zda JDK olmad\u0131\u011f\u0131n\u0131 ya da en az\u0131ndan \u015fimdi kullanaca\u011f\u0131m\u0131z JDK da\u011f\u0131t\u0131m ve s\u00fcr\u00fcm\u00fcn\u00fcn olmad\u0131\u011f\u0131 farzedelim. Proje dizininde a\u015fa\u011f\u0131daki komutu \u00e7al\u0131\u015ft\u0131rarak proje dosyalar\u0131m\u0131z\u0131 ve ihtiyac\u0131m\u0131z olan ara\u00e7lar\u0131 i\u00e7eren bir \u00e7al\u0131\u015fma ortam\u0131 haz\u0131rlayabilriz.</p> <pre><code>cd dev\ndocker run -it --rm -v $(pwd)/demo:/work -w /work eclipse-temurin:17-jdk bash\n</code></pre>"},{"location":"kubernetes/","title":"Kubernetes","text":""},{"location":"kubernetes/1-kurulum/","title":"Kurulum","text":"<p>Lokalde kubernetes kurulumu i\u00e7in a\u015fa\u011f\u0131daki linklerden faydalanabilirsiniz.</p> <ul> <li>kind</li> <li>minikube</li> <li>Docker Desktop</li> <li>Rancher Desktop</li> </ul> <p>Sonras\u0131nda ortam\u0131m\u0131za eri\u015febilmek i\u00e7in <code>kubectl</code> arac\u0131n\u0131 kullanmam\u0131z gerekecek. Onu da a\u015fa\u011fda\u0131ki linkten faydalanarak kurabilirsiniz.</p> <p>https://kubernetes.io/docs/tasks/tools/</p> <p>Yukar\u0131daki kurulumlar\u0131 yapt\u0131ktan sonra ev dizininde (linux'da <code>/home/$user</code> alt\u0131nda, windows'da <code>C:\\Kullan\u0131c\u0131lar\\$user</code> alt\u0131nda) <code>.kube</code> dizini alt\u0131nda <code>config</code> ad\u0131nda bir dosya bulunmas\u0131 gerekiyor. Bu dosyada ortama eri\u015fmek i\u00e7in gerekli bilgiler bulunuyor (IP, sertifika, token vs).</p> <p>Kurulumlar\u0131n ba\u015far\u0131l\u0131 oldu\u011funu test etmek i\u00e7in a\u015fa\u011f\u0131daki komutu \u00e7al\u0131\u015ft\u0131r\u0131n:</p> <p><code>kubectl get nodes</code></p> <p>Bu komutun sonucunda a\u015fa\u011f\u0131dakine benzer bir \u00e7\u0131kt\u0131 alacaks\u0131n\u0131z:</p> <pre><code>\u276f kubectl get nodes\nNAME                 STATUS   ROLES           AGE   VERSION\nkind-control-plane   Ready    control-plane   41s   v1.27.3\n</code></pre>"},{"location":"kubernetes/2-helloworld/","title":"Hello World","text":"<p><code>kubectl run hello --image hello-world</code> komutu ile basit bir imaj\u0131 kubernetes ortam\u0131n\u0131za \u00e7ekip \u00e7al\u0131\u015ft\u0131rabilirsiniz. Container \u00e7al\u0131\u015ft\u0131\u011f\u0131 zaman a\u015fa\u011f\u0131daki \u00e7\u0131kt\u0131y\u0131 \u00fcretir:</p> <pre><code>\u276f kubectl run hello --image hello-world\npod/hello created\n</code></pre> <p>Container'\u0131n as\u0131l \u00e7\u0131kt\u0131s\u0131n\u0131 g\u00f6rebilmek i\u00e7in a\u015fa\u011f\u0131daki komutla container'\u0131n loguna bakmam\u0131z gerekiyor:</p> <pre><code>\u276f kubectl logs hello\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre> <p>\u0130\u015fimiz bitince <code>kubectl delete pod hello</code> komutu ile container'\u0131 silebiliriz.</p>"},{"location":"kubernetes/3-bash/","title":"Bash","text":"<p>Bu ba\u015fl\u0131kta docker'\u0131n en yayg\u0131n kullan\u0131m alanlar\u0131ndan biri olan ge\u00e7ici \u00e7al\u0131\u015fma ortamlar\u0131n\u0131 inceleyece\u011fiz.</p>"}]}